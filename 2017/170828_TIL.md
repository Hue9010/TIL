
중복코드를 제거하는 방법
1. 일차적으론 메소드(클래스 안에서만 가능)
클래스 간의 중복을 제거하는 법
1. 중복되는 코드들을 새로운 클래스로 만든다.
2. 상속
3. 컴포지션(조합)

인터페이스에 인터페이스를 상속 받은 애들은 부모의 메소드들을 상속 받는다.
즉 자신과 자신의 부모 인터페이스ㅡ이 메소드들을 구현해야한다.
> public interface List<E> extends Collection<E>

1. private : 클래스 내에서만 가능
2. public : 다른 패키지 포함 모두 가능
3. protected : 같은 패키지 내에서 접근 가능, 또한 다른 패키지에서 상속받은 클래스에서도 가능
4. default or package : 클래스 내와 같은 패키지 내에서 가능

중복을 찾는 방법은 추상화를 통해서 중복되는 곳을 파악 해야한다.
- 추상화를 통한 중복 제거

> public abstract class CaffeinBeverage implements Comparable<CaffeinBeverage>

같은 형태로 부모로 쓸 추상클래스에 인터페이스를 상속하면 해당 인터페이스의 메소드들을 부모가 구현 할 수도 있고, 구현을 안 함으로써 자식이 구현하게 해 둘수도 있다. (부모가 다 하면 자식들의 제약조건이 커져 자유도가 떨어진다.)

인터페이스의 일차 목적은 명세를 만드는 것
인터페이스를 만들고 그에 따라 구현 하는 과정에서 추상화를 통해 중복을 발견하고, 그걸 해결하기 위해 abstract를 사용하게 된다.

> public abstract class CaffeinBeverage implements Brewable

  같은 형태가 있으면 Brewable 부분을 추상 클래스의 추상 메소드로 정의 해둘수도 있지만, 그렇게 하면 해당 클래스에 종속이 된다. 그러나 인터페이스로 뽑으면 해당 인터페이스의 기능은 좀 더 자유롭게(?) 다른 곳에서도 쓰일 수 있다.(그 소리는 좀더 보편적인 기능을 인터페이스로 만드는게 좋을 것 같다.)

개발 문화가 잘 되어 있는지, 역량이 있는지 판단 질문
1. git이나 svn같은 버전관리 프로그램을 쓰고 있느냐(아니면 절대 가면 안된다)
2. CI(지속적 통합) 도구를 쓰는 문화인가
3. test를 하느냐(junit과 같은 것을 사용하여 단위 테스트를 하는가)
4. 코드 리뷰를 하는가?(이건 2번 전후 정도로의 순위로 보면 된다)
 - qa팀이 있어도 그건 통합테스트 개념이나 서비스를 사용자한테 보여주는 부분을 위해 하는것이지 자신이 짠 코드 자체에 대한 단위테스트는 별개다

in out 방식
out in 방식  방식의 차이일 뿐이다. out in 방식이 처음인 사람한테는 좀더 쉬울거다. 테스트코드도 바깥에서부터 만들기 시작한다.


```
CaffeineBeverage beverage = new Coffee();

if (beverage  instanceof Coffee) {
    Coffee coffee = (Coffee)beverage;
}
```
이 코드의 인스턴스는 하나이다. Coffee coffee 에다가 beverage를 넣어준 것이라서
instanceof 라는 예약어이다

부모도 인스턴스 필드를 가질 수 있다.

```
public class Sonata extends Car {
private int tripD;

Sonata(int tripDistance) {
		//super();
		tripD = tirpDistance;
	}
}
```
이런 식의 코드가 있으면 자식이 생성될때 주석 처리 한 super() 즉, 부모의 생성자를 먼저 호출 한 다음 자신의 생성자 .
super()가 있어도 부모 인스턴스를 생성하는게 아니라 부모의 상태값들(모든 기능을 쓰기 위해) 상태를 초기화 시킨다음 자신을 만든다.
즉, 자식이 생성될려면 부모를 먼저 초기화 시킨다음 자신을 초기화 시키라고 강제화를 시키라는 규약 같은 것이다.
